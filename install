#!/usr/bin/env python3.6

"""Install packages, stored as subfolders, in this directory.

Wrapper around GNU stow for regular packages
plus some custom code for special packages that behave differently.
Mostly intended for dotfile management,
but can probably be used otherwise.

Packages are installed from the containing directory
to $HOME.

This script was made by FichteFoll <fichtefoll2@googlemail.com>
and is placed in the Public Domain.
"""

import logging
import os
from pathlib import Path
import subprocess
import sys
from typing import Iterable

dotfiles_path = Path(__file__).parent

# Sublime Text doesn't work well with symlinked files,
# so we install its config files as hardlinks instead.
HARD_STOW_PACKAGES = {"sublime-text"}

l = logging.getLogger(__name__)


def is_package(path: Path) -> bool:
    """Filter out paths that don't represent packages."""
    if not path.is_dir():
        return False
    elif path.name.startswith("."):
        return False
    return True


def stow(package_names: Iterable[str],
         dir: Path = dotfiles_path,
         target: Path = Path.home(),
         args: Iterable[str] = (),
         ) -> int:
    """Install packages using GNU stow.

    Usually we don't want folding because the directories could be modified
    and then added files would end up in the dotfiles repo
    """
    cmd = ["stow",
           f'--dir={dir!s}',
           f'--target={target!s}',
           '--no-folding',  # never do folding
           f'--verbose={1 if l.getEffectiveLevel() >= logging.INFO else 2}',
           *args,
           *package_names]

    l.info(f"Calling {cmd}")
    return subprocess.call(cmd, stdout=sys.stdout, stderr=sys.stderr)


def hard_stow(package_names: Iterable[str],
              dir: Path = dotfiles_path,
              target: Path = Path.home(),
              adopt: bool = False,
              ) -> int:
    """Install packages similar to GNU stow, but with hardlinks.

    Because this is a simple implementation and stow is generally more robust,
    it is recommended to use that instead.
    However, in the occasion that an application doesn't work properly
    with symlinks in the default direction,
    mostly because of filesystem notifications,
    you may want to use this.
    """
    # TODO uninstalling
    ret = 0
    for package_name in package_names:
        l.debug(f"Planning hard-stow of package {package_name}...")
        package_path = dir / package_name

        relpaths = set()
        existing_files = set()
        conflicting_files = set()

        # collect files and check for conflicts
        for source_path in package_path.glob("**/*"):
            if source_path.is_dir():
                continue
            relpath = source_path.relative_to(package_path)
            target_path = target / relpath
            if target_path.exists():
                existing_files.add(relpath)
                if source_path.samefile(target_path):
                    l.debug(f"--- Skipping {relpath!s} as it is already pointed at by {target_path!s}")
                    continue
                else:
                    conflicting_files.add(relpath)

            relpaths.add(relpath)

        if conflicting_files and not adopt:
            for path in conflicting_files:
                l.error(f"File '{path!s}' exists in the target location")
            l.error(f"Skipping installation of {package_name!r}")
            continue

        if not relpaths:
            l.debug(f"Nothing to do for {package_name}")
            continue

        l.debug(f"Processing {package_name}...")
        try:
            for relpath in relpaths:
                source_path, target_path = package_path / relpath, target / relpath

                if relpath in existing_files:
                    l.info(f"Adopting '{relpath!s}' into package {package_name!r}")
                    l.debug(f"RM: {source_path!s}")
                    source_path.unlink()
                    l.debug(f"HLINK: {target_path!s} -> {source_path!s}")
                    os.link(target_path, source_path)
                else:
                    l.debug(f"HLINK: {source_path!s} -> {target_path!s}")
                    target_path.parent.mkdir(parents=True, exist_ok=True)
                    os.link(source_path, target_path)
        except:
            # TODO roll back
            ret = 10

    return ret


def main():
    # TODO args
    # nargs (packages; default to subfolders)
    # -n, --no
    # --adopt
    # --exclude (fnmatch)
    # -v, --verbose
    # -S, --stow
    # -R, --restow ?
    # -D, --delete
    l.addHandler(logging.StreamHandler())
    l.setLevel(logging.DEBUG)

    additional_stow_args = sys.argv[1:]

    package_paths = {path for path in dotfiles_path.glob("*") if is_package(path)}
    package_names = {path.name for path in package_paths}
    l.info(f"Installing {len(package_names)} packages")
    l.debug(f"Packages: {', '.join(sorted(package_names))}")

    hard_package_names = package_names & HARD_STOW_PACKAGES
    normal_package_names = package_names - hard_package_names

    result = stow(normal_package_names, args=additional_stow_args)
    result += hard_stow(hard_package_names, adopt="--adopt" in additional_stow_args)

    return result


if __name__ == '__main__':
    sys.exit(main())
